"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.CucumberAdapter = exports.default = void 0;

require("source-map-support/register");

var Cucumber = _interopRequireWildcard(require("cucumber"));

var _mockery = _interopRequireDefault(require("mockery"));

var _isGlob = _interopRequireDefault(require("is-glob"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _reporter = _interopRequireDefault(require("./reporter"));

var _Hookrunner = _interopRequireDefault(require("./Hookrunner"));

var _events = require("events");

var _config = require("@wdio/config");

var _sync = require("@wdio/sync");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

class CucumberAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cwd = process.cwd();
    this.cid = cid;
    this.specs = specs;
    this.reporter = reporter;
    this.capabilities = capabilities;
    this.config = config;
    this.cucumberOpts = Object.assign(_constants.DEFAULT_OPTS, config.cucumberOpts);
  }

  async run() {
    let runtimeError;
    let result;
    Cucumber.supportCodeLibraryBuilder.reset(this.cwd);

    try {
      await (0, _config.executeHooksWithArgs)(this.config.before, [this.capabilities, this.specs]);
      this.registerCompilers();
      this.loadSpecFiles();
      this.wrapSteps();
      Cucumber.setDefaultTimeout(this.cucumberOpts.timeout);
      const supportCodeLibrary = Cucumber.supportCodeLibraryBuilder.finalize();
      const eventBroadcaster = new _events.EventEmitter(); // eslint-disable-next-line no-new

      new _Hookrunner.default(eventBroadcaster, this.config);
      const reporterOptions = {
        capabilities: this.capabilities,
        ignoreUndefinedDefinitions: Boolean(this.cucumberOpts.ignoreUndefinedDefinitions),
        failAmbiguousDefinitions: Boolean(this.cucumberOpts.failAmbiguousDefinitions),
        tagsInTitle: Boolean(this.cucumberOpts.tagsInTitle)
      };
      new _reporter.default(eventBroadcaster, reporterOptions, this.cid, this.specs, this.reporter);
      const pickleFilter = new Cucumber.PickleFilter({
        featurePaths: this.specs,
        names: this.cucumberOpts.name,
        tagExpression: this.cucumberOpts.tagExpression
      });
      const testCases = await Cucumber.getTestCasesFromFilesystem({
        cwd: this.cwd,
        eventBroadcaster,
        featurePaths: this.specs,
        order: this.cucumberOpts.order,
        pickleFilter
      });
      const runtime = new Cucumber.Runtime({
        eventBroadcaster,
        options: this.cucumberOpts,
        supportCodeLibrary,
        testCases
      });
      await (0, _config.executeHooksWithArgs)(this.config.before, [this.capabilities, this.specs]);
      result = (await runtime.start()) ? 0 : 1;
    } catch (e) {
      runtimeError = e;
      result = 1;
    }

    await (0, _config.executeHooksWithArgs)(this.config.after, [runtimeError || result, this.capabilities, this.specs]);
    /**
     * in case the spec has a runtime error throw after the wdio hook
     */

    if (runtimeError) {
      throw runtimeError;
    } //await reporter.waitUntilSettled()


    return result;
  }

  registerCompilers() {
    if (!this.cucumberOpts.compiler || this.cucumberOpts.compiler.length === 0) {
      return; // throw new Error('A compiler must be defined')
    }

    this.cucumberOpts.compiler.forEach(compiler => {
      const parts = compiler.split(':');

      require(parts[1]);
    });
  }

  requiredFiles() {
    return this.cucumberOpts.require.reduce((files, requiredFile) => {
      if ((0, _isGlob.default)(requiredFile)) {
        return files.concat(_glob.default.sync(requiredFile));
      } else {
        return files.concat([requiredFile]);
      }
    }, []);
  }

  loadSpecFiles() {
    // we use mockery to allow people to import 'our' cucumber even though their spec files are in their folders
    // because of that we don't have to attach anything to the global object, and the current cucumber spec files
    // should just work with no changes with this framework
    _mockery.default.enable({
      useCleanCache: false,
      warnOnReplace: false,
      warnOnUnregistered: false
    });

    _mockery.default.registerMock('cucumber', Cucumber);

    this.requiredFiles().forEach(codePath => {
      let absolutePath;

      if (_path.default.isAbsolute(codePath)) {
        absolutePath = codePath;
      } else {
        absolutePath = _path.default.join(process.cwd(), codePath);
      } // This allows rerunning a stepDefinitions file


      delete require.cache[require.resolve(absolutePath)];

      require(absolutePath);
    });

    _mockery.default.disable();
  }
  /**
   * wraps step definition code with sync/async runner with a retry option
   */


  wrapSteps() {
    const sync = this.config.sync;
    const wrapStepSync = this.wrapStepSync;
    const wrapStepAsync = this.wrapStepAsync;
    Cucumber.setDefinitionFunctionWrapper(function syncAsyncRetryWrapper(fn, options = {}) {
      let retryTest = isFinite(options.retry) ? parseInt(options.retry, 10) : 0;
      let wrappedFunction = fn.name === 'async' || sync === false ? wrapStepAsync(fn, retryTest) : wrapStepSync(fn, retryTest);
      return wrappedFunction;
    });
  }
  /**
   * wrap step definition to enable retry ability
   * @param  {Function} code       step definition
   * @param  {Number}   retryTest  amount of allowed repeats is case of a failure
   * @return {Function}            wrapped step definiton for sync WebdriverIO code
   */


  wrapStepSync(code, retryTest = 0) {
    return function (...args) {
      return new Promise((resolve, reject) => (0, _sync.runFnInFiberContext)(_sync.executeSync.bind(this, code, retryTest, args), resultPromise => resultPromise.then(resolve, reject)).apply(this));
    };
  }
  /**
   * wrap step definition to enable retry ability
   * @param  {Function} code       step definitoon
   * @param  {Number}   retryTest  amount of allowed repeats is case of a failure
   * @return {Function}            wrapped step definiton for async WebdriverIO code
   */


  wrapStepAsync(code, retryTest = 0) {
    return function (...args) {
      return _sync.executeAsync.call(this, code, retryTest, args);
    };
  }

}

exports.CucumberAdapter = CucumberAdapter;
const _CucumberAdapter = CucumberAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.run = async function (...args) {
  const adapter = new _CucumberAdapter(...args);
  const result = await adapter.run();
  return result;
};

var _default = adapterFactory;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJDdWN1bWJlckFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsImNpZCIsImNvbmZpZyIsInNwZWNzIiwiY2FwYWJpbGl0aWVzIiwicmVwb3J0ZXIiLCJjd2QiLCJwcm9jZXNzIiwiY3VjdW1iZXJPcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiREVGQVVMVF9PUFRTIiwicnVuIiwicnVudGltZUVycm9yIiwicmVzdWx0IiwiQ3VjdW1iZXIiLCJzdXBwb3J0Q29kZUxpYnJhcnlCdWlsZGVyIiwicmVzZXQiLCJiZWZvcmUiLCJyZWdpc3RlckNvbXBpbGVycyIsImxvYWRTcGVjRmlsZXMiLCJ3cmFwU3RlcHMiLCJzZXREZWZhdWx0VGltZW91dCIsInRpbWVvdXQiLCJzdXBwb3J0Q29kZUxpYnJhcnkiLCJmaW5hbGl6ZSIsImV2ZW50QnJvYWRjYXN0ZXIiLCJFdmVudEVtaXR0ZXIiLCJIb29rcnVubmVyIiwicmVwb3J0ZXJPcHRpb25zIiwiaWdub3JlVW5kZWZpbmVkRGVmaW5pdGlvbnMiLCJCb29sZWFuIiwiZmFpbEFtYmlndW91c0RlZmluaXRpb25zIiwidGFnc0luVGl0bGUiLCJDdWN1bWJlclJlcG9ydGVyIiwicGlja2xlRmlsdGVyIiwiUGlja2xlRmlsdGVyIiwiZmVhdHVyZVBhdGhzIiwibmFtZXMiLCJuYW1lIiwidGFnRXhwcmVzc2lvbiIsInRlc3RDYXNlcyIsImdldFRlc3RDYXNlc0Zyb21GaWxlc3lzdGVtIiwib3JkZXIiLCJydW50aW1lIiwiUnVudGltZSIsIm9wdGlvbnMiLCJzdGFydCIsImUiLCJhZnRlciIsImNvbXBpbGVyIiwibGVuZ3RoIiwiZm9yRWFjaCIsInBhcnRzIiwic3BsaXQiLCJyZXF1aXJlIiwicmVxdWlyZWRGaWxlcyIsInJlZHVjZSIsImZpbGVzIiwicmVxdWlyZWRGaWxlIiwiY29uY2F0IiwiZ2xvYiIsInN5bmMiLCJtb2NrZXJ5IiwiZW5hYmxlIiwidXNlQ2xlYW5DYWNoZSIsIndhcm5PblJlcGxhY2UiLCJ3YXJuT25VbnJlZ2lzdGVyZWQiLCJyZWdpc3Rlck1vY2siLCJjb2RlUGF0aCIsImFic29sdXRlUGF0aCIsInBhdGgiLCJpc0Fic29sdXRlIiwiam9pbiIsImNhY2hlIiwicmVzb2x2ZSIsImRpc2FibGUiLCJ3cmFwU3RlcFN5bmMiLCJ3cmFwU3RlcEFzeW5jIiwic2V0RGVmaW5pdGlvbkZ1bmN0aW9uV3JhcHBlciIsInN5bmNBc3luY1JldHJ5V3JhcHBlciIsImZuIiwicmV0cnlUZXN0IiwiaXNGaW5pdGUiLCJyZXRyeSIsInBhcnNlSW50Iiwid3JhcHBlZEZ1bmN0aW9uIiwiY29kZSIsImFyZ3MiLCJQcm9taXNlIiwicmVqZWN0IiwiZXhlY3V0ZVN5bmMiLCJiaW5kIiwicmVzdWx0UHJvbWlzZSIsInRoZW4iLCJhcHBseSIsImV4ZWN1dGVBc3luYyIsImNhbGwiLCJfQ3VjdW1iZXJBZGFwdGVyIiwiYWRhcHRlckZhY3RvcnkiLCJhZGFwdGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsZUFBTixDQUFzQjtBQUNsQkMsRUFBQUEsV0FBVyxDQUFFQyxHQUFGLEVBQU9DLE1BQVAsRUFBZUMsS0FBZixFQUFzQkMsWUFBdEIsRUFBb0NDLFFBQXBDLEVBQThDO0FBQ3JELFNBQUtDLEdBQUwsR0FBV0MsT0FBTyxDQUFDRCxHQUFSLEVBQVg7QUFDQSxTQUFLTCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLRSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLRSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtELFlBQUwsR0FBb0JBLFlBQXBCO0FBQ0EsU0FBS0YsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS00sWUFBTCxHQUFvQkMsTUFBTSxDQUFDQyxNQUFQLENBQWNDLHVCQUFkLEVBQTRCVCxNQUFNLENBQUNNLFlBQW5DLENBQXBCO0FBQ0g7O0FB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cUYsYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEN1Y3VtYmVyIGZyb20gJ2N1Y3VtYmVyJ1xuaW1wb3J0IG1vY2tlcnkgZnJvbSAnbW9ja2VyeSdcbmltcG9ydCBpc0dsb2IgZnJvbSAnaXMtZ2xvYidcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuXG5pbXBvcnQgQ3VjdW1iZXJSZXBvcnRlciBmcm9tICcuL3JlcG9ydGVyJ1xuXG5pbXBvcnQgSG9va3J1bm5lciBmcm9tICcuL0hvb2tydW5uZXInXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnXG5cbmltcG9ydCB7IGV4ZWN1dGVIb29rc1dpdGhBcmdzIH0gZnJvbSAnQHdkaW8vY29uZmlnJ1xuaW1wb3J0IHsgZXhlY3V0ZVN5bmMsIGV4ZWN1dGVBc3luYywgcnVuRm5JbkZpYmVyQ29udGV4dCB9IGZyb20gJ0B3ZGlvL3N5bmMnXG5pbXBvcnQgeyBERUZBVUxUX09QVFMgfSBmcm9tICcuL2NvbnN0YW50cydcblxuY2xhc3MgQ3VjdW1iZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoY2lkLCBjb25maWcsIHNwZWNzLCBjYXBhYmlsaXRpZXMsIHJlcG9ydGVyKSB7XG4gICAgICAgIHRoaXMuY3dkID0gcHJvY2Vzcy5jd2QoKVxuICAgICAgICB0aGlzLmNpZCA9IGNpZFxuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3NcbiAgICAgICAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyXG4gICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gICAgICAgIHRoaXMuY3VjdW1iZXJPcHRzID0gT2JqZWN0LmFzc2lnbihERUZBVUxUX09QVFMsIGNvbmZpZy5jdWN1bWJlck9wdHMpXG4gICAgfVxuXG4gICAgYXN5bmMgcnVuICgpIHtcbiAgICAgICAgbGV0IHJ1bnRpbWVFcnJvclxuICAgICAgICBsZXQgcmVzdWx0XG5cbiAgICAgICAgQ3VjdW1iZXIuc3VwcG9ydENvZGVMaWJyYXJ5QnVpbGRlci5yZXNldCh0aGlzLmN3ZClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZUhvb2tzV2l0aEFyZ3ModGhpcy5jb25maWcuYmVmb3JlLCBbdGhpcy5jYXBhYmlsaXRpZXMsIHRoaXMuc3BlY3NdKVxuXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29tcGlsZXJzKClcbiAgICAgICAgICAgIHRoaXMubG9hZFNwZWNGaWxlcygpXG4gICAgICAgICAgICB0aGlzLndyYXBTdGVwcygpXG4gICAgICAgICAgICBDdWN1bWJlci5zZXREZWZhdWx0VGltZW91dCh0aGlzLmN1Y3VtYmVyT3B0cy50aW1lb3V0KVxuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydENvZGVMaWJyYXJ5ID0gQ3VjdW1iZXIuc3VwcG9ydENvZGVMaWJyYXJ5QnVpbGRlci5maW5hbGl6ZSgpXG5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50QnJvYWRjYXN0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICAgIG5ldyBIb29rcnVubmVyKGV2ZW50QnJvYWRjYXN0ZXIsIHRoaXMuY29uZmlnKVxuICAgICAgICAgICAgY29uc3QgcmVwb3J0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogdGhpcy5jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgaWdub3JlVW5kZWZpbmVkRGVmaW5pdGlvbnM6IEJvb2xlYW4odGhpcy5jdWN1bWJlck9wdHMuaWdub3JlVW5kZWZpbmVkRGVmaW5pdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZhaWxBbWJpZ3VvdXNEZWZpbml0aW9uczogQm9vbGVhbih0aGlzLmN1Y3VtYmVyT3B0cy5mYWlsQW1iaWd1b3VzRGVmaW5pdGlvbnMpLFxuICAgICAgICAgICAgICAgIHRhZ3NJblRpdGxlOiBCb29sZWFuKHRoaXMuY3VjdW1iZXJPcHRzLnRhZ3NJblRpdGxlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXcgQ3VjdW1iZXJSZXBvcnRlcihldmVudEJyb2FkY2FzdGVyLCByZXBvcnRlck9wdGlvbnMsIHRoaXMuY2lkLCB0aGlzLnNwZWNzLCB0aGlzLnJlcG9ydGVyKVxuXG4gICAgICAgICAgICBjb25zdCBwaWNrbGVGaWx0ZXIgPSBuZXcgQ3VjdW1iZXIuUGlja2xlRmlsdGVyKHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUGF0aHM6IHRoaXMuc3BlY3MsXG4gICAgICAgICAgICAgICAgbmFtZXM6IHRoaXMuY3VjdW1iZXJPcHRzLm5hbWUsXG4gICAgICAgICAgICAgICAgdGFnRXhwcmVzc2lvbjogdGhpcy5jdWN1bWJlck9wdHMudGFnRXhwcmVzc2lvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IGF3YWl0IEN1Y3VtYmVyLmdldFRlc3RDYXNlc0Zyb21GaWxlc3lzdGVtKHtcbiAgICAgICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgICAgIGV2ZW50QnJvYWRjYXN0ZXIsXG4gICAgICAgICAgICAgICAgZmVhdHVyZVBhdGhzOiB0aGlzLnNwZWNzLFxuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLmN1Y3VtYmVyT3B0cy5vcmRlcixcbiAgICAgICAgICAgICAgICBwaWNrbGVGaWx0ZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjb25zdCBydW50aW1lID0gbmV3IEN1Y3VtYmVyLlJ1bnRpbWUoe1xuICAgICAgICAgICAgICAgIGV2ZW50QnJvYWRjYXN0ZXIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5jdWN1bWJlck9wdHMsXG4gICAgICAgICAgICAgICAgc3VwcG9ydENvZGVMaWJyYXJ5LFxuICAgICAgICAgICAgICAgIHRlc3RDYXNlc1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZUhvb2tzV2l0aEFyZ3ModGhpcy5jb25maWcuYmVmb3JlLCBbdGhpcy5jYXBhYmlsaXRpZXMsIHRoaXMuc3BlY3NdKVxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVudGltZS5zdGFydCgpID8gMCA6IDFcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcnVudGltZUVycm9yID0gZVxuICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZXhlY3V0ZUhvb2tzV2l0aEFyZ3ModGhpcy5jb25maWcuYWZ0ZXIsIFtydW50aW1lRXJyb3IgfHwgcmVzdWx0LCB0aGlzLmNhcGFiaWxpdGllcywgdGhpcy5zcGVjc10pXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluIGNhc2UgdGhlIHNwZWMgaGFzIGEgcnVudGltZSBlcnJvciB0aHJvdyBhZnRlciB0aGUgd2RpbyBob29rXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocnVudGltZUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBydW50aW1lRXJyb3JcbiAgICAgICAgfVxuICAgICAgICAvL2F3YWl0IHJlcG9ydGVyLndhaXRVbnRpbFNldHRsZWQoKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZWdpc3RlckNvbXBpbGVycyAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdWN1bWJlck9wdHMuY29tcGlsZXIgfHwgdGhpcy5jdWN1bWJlck9wdHMuY29tcGlsZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ0EgY29tcGlsZXIgbXVzdCBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VjdW1iZXJPcHRzLmNvbXBpbGVyLmZvckVhY2goY29tcGlsZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBjb21waWxlci5zcGxpdCgnOicpXG4gICAgICAgICAgICByZXF1aXJlKHBhcnRzWzFdKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJlcXVpcmVkRmlsZXMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdWN1bWJlck9wdHMucmVxdWlyZS5yZWR1Y2UoKGZpbGVzLCByZXF1aXJlZEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0dsb2IocmVxdWlyZWRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlcy5jb25jYXQoZ2xvYi5zeW5jKHJlcXVpcmVkRmlsZSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlcy5jb25jYXQoW3JlcXVpcmVkRmlsZV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH1cblxuICAgIGxvYWRTcGVjRmlsZXMgKCkge1xuICAgICAgICAvLyB3ZSB1c2UgbW9ja2VyeSB0byBhbGxvdyBwZW9wbGUgdG8gaW1wb3J0ICdvdXInIGN1Y3VtYmVyIGV2ZW4gdGhvdWdoIHRoZWlyIHNwZWMgZmlsZXMgYXJlIGluIHRoZWlyIGZvbGRlcnNcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYXR0YWNoIGFueXRoaW5nIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBhbmQgdGhlIGN1cnJlbnQgY3VjdW1iZXIgc3BlYyBmaWxlc1xuICAgICAgICAvLyBzaG91bGQganVzdCB3b3JrIHdpdGggbm8gY2hhbmdlcyB3aXRoIHRoaXMgZnJhbWV3b3JrXG4gICAgICAgIG1vY2tlcnkuZW5hYmxlKHtcbiAgICAgICAgICAgIHVzZUNsZWFuQ2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgd2Fybk9uUmVwbGFjZTogZmFsc2UsXG4gICAgICAgICAgICB3YXJuT25VbnJlZ2lzdGVyZWQ6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICAgIG1vY2tlcnkucmVnaXN0ZXJNb2NrKCdjdWN1bWJlcicsIEN1Y3VtYmVyKVxuICAgICAgICB0aGlzLnJlcXVpcmVkRmlsZXMoKS5mb3JFYWNoKChjb2RlUGF0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFic29sdXRlUGF0aFxuICAgICAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZShjb2RlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVBhdGggPSBjb2RlUGF0aFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgY29kZVBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyByZXJ1bm5pbmcgYSBzdGVwRGVmaW5pdGlvbnMgZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHJlcXVpcmUuY2FjaGVbcmVxdWlyZS5yZXNvbHZlKGFic29sdXRlUGF0aCldXG4gICAgICAgICAgICByZXF1aXJlKGFic29sdXRlUGF0aClcbiAgICAgICAgfSlcbiAgICAgICAgbW9ja2VyeS5kaXNhYmxlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3cmFwcyBzdGVwIGRlZmluaXRpb24gY29kZSB3aXRoIHN5bmMvYXN5bmMgcnVubmVyIHdpdGggYSByZXRyeSBvcHRpb25cbiAgICAgKi9cbiAgICB3cmFwU3RlcHMgKCkge1xuICAgICAgICBjb25zdCBzeW5jID0gdGhpcy5jb25maWcuc3luY1xuICAgICAgICBjb25zdCB3cmFwU3RlcFN5bmMgPSB0aGlzLndyYXBTdGVwU3luY1xuICAgICAgICBjb25zdCB3cmFwU3RlcEFzeW5jID0gdGhpcy53cmFwU3RlcEFzeW5jXG5cbiAgICAgICAgQ3VjdW1iZXIuc2V0RGVmaW5pdGlvbkZ1bmN0aW9uV3JhcHBlcihmdW5jdGlvbiBzeW5jQXN5bmNSZXRyeVdyYXBwZXIgKGZuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGxldCByZXRyeVRlc3QgPSBpc0Zpbml0ZShvcHRpb25zLnJldHJ5KSA/IHBhcnNlSW50KG9wdGlvbnMucmV0cnksIDEwKSA6IDBcbiAgICAgICAgICAgIGxldCB3cmFwcGVkRnVuY3Rpb24gPSBmbi5uYW1lID09PSAnYXN5bmMnIHx8IHN5bmMgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgPyB3cmFwU3RlcEFzeW5jKGZuLCByZXRyeVRlc3QpIDogd3JhcFN0ZXBTeW5jKGZuLCByZXRyeVRlc3QpXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZEZ1bmN0aW9uXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd3JhcCBzdGVwIGRlZmluaXRpb24gdG8gZW5hYmxlIHJldHJ5IGFiaWxpdHlcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY29kZSAgICAgICBzdGVwIGRlZmluaXRpb25cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgcmV0cnlUZXN0ICBhbW91bnQgb2YgYWxsb3dlZCByZXBlYXRzIGlzIGNhc2Ugb2YgYSBmYWlsdXJlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgd3JhcHBlZCBzdGVwIGRlZmluaXRvbiBmb3Igc3luYyBXZWJkcml2ZXJJTyBjb2RlXG4gICAgICovXG4gICAgd3JhcFN0ZXBTeW5jIChjb2RlLCByZXRyeVRlc3QgPSAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJ1bkZuSW5GaWJlckNvbnRleHQoXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVN5bmMuYmluZCh0aGlzLCBjb2RlLCByZXRyeVRlc3QsIGFyZ3MpLFxuICAgICAgICAgICAgICAgIChyZXN1bHRQcm9taXNlKSA9PiByZXN1bHRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgKS5hcHBseSh0aGlzKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdyYXAgc3RlcCBkZWZpbml0aW9uIHRvIGVuYWJsZSByZXRyeSBhYmlsaXR5XG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNvZGUgICAgICAgc3RlcCBkZWZpbml0b29uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIHJldHJ5VGVzdCAgYW1vdW50IG9mIGFsbG93ZWQgcmVwZWF0cyBpcyBjYXNlIG9mIGEgZmFpbHVyZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgIHdyYXBwZWQgc3RlcCBkZWZpbml0b24gZm9yIGFzeW5jIFdlYmRyaXZlcklPIGNvZGVcbiAgICAgKi9cbiAgICB3cmFwU3RlcEFzeW5jIChjb2RlLCByZXRyeVRlc3QgPSAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYy5jYWxsKHRoaXMsIGNvZGUsIHJldHJ5VGVzdCwgYXJncylcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgX0N1Y3VtYmVyQWRhcHRlciA9IEN1Y3VtYmVyQWRhcHRlclxuY29uc3QgYWRhcHRlckZhY3RvcnkgPSB7fVxuXG5hZGFwdGVyRmFjdG9yeS5ydW4gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBuZXcgX0N1Y3VtYmVyQWRhcHRlciguLi5hcmdzKVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkYXB0ZXIucnVuKClcbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFkYXB0ZXJGYWN0b3J5XG5leHBvcnQgeyBDdWN1bWJlckFkYXB0ZXIsIGFkYXB0ZXJGYWN0b3J5IH1cbiJdfQ==